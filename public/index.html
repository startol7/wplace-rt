<!doctype html>
<meta charset="utf-8" />
<title>wplace-rt 最小キャンバス</title>
<style>
  body { font-family: system-ui, sans-serif; margin: 16px; }
  #wrap { display: flex; gap: 16px; align-items: center; margin-bottom: 8px; flex-wrap: wrap; }
  canvas { border: 1px solid #ccc; image-rendering: pixelated; cursor: crosshair; }
  .hint { color: #666; font-size: 12px; }
  #status { font-size: 12px; color:#666; }
</style>

<div id="wrap">
  <div>色 <input type="color" id="color" value="#ff0000"></div>
  <div>クールダウン: <span id="cd">OK</span></div>
  <span id="status">接続中…</span>
  <div class="hint">グリッド：256×256 / 1マス=3px（コード先頭で変更可）</div>
</div>
<canvas id="cv"></canvas>

<script>
(() => {
  // ===== 設定 =====
  const W = 256, H = 256;   // グリッド
  const CELL = 3;           // 1マスの表示サイズ(px)
  const COOLDOWN_MS = 3000; // クールダウン

  // UI
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d');
  const colorEl = document.getElementById('color');
  const cdEl = document.getElementById('cd');
  const statusEl = document.getElementById('status');

  // 高DPI
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  cv.width  = W * CELL * dpr;
  cv.height = H * CELL * dpr;
  cv.style.width  = (W * CELL) + 'px';
  cv.style.height = (H * CELL) + 'px';
  ctx.scale(dpr, dpr);

  // グリッド描画
  function drawGrid() {
    ctx.fillStyle = '#fff';
    ctx.fillRect(0, 0, W*CELL, H*CELL);
    ctx.strokeStyle = '#eee';
    ctx.lineWidth = 1;
    for (let i = 0; i <= W; i++) {
      ctx.beginPath(); ctx.moveTo(i*CELL, 0); ctx.lineTo(i*CELL, H*CELL); ctx.stroke();
    }
    for (let j = 0; j <= H; j++) {
      ctx.beginPath(); ctx.moveTo(0, j*CELL); ctx.lineTo(W*CELL, j*CELL); ctx.stroke();
    }
  }

  function fillCell(x, y, col) {
    ctx.fillStyle = col;
    ctx.fillRect(x*CELL, y*CELL, CELL, CELL);
  }

  drawGrid();

  // ===== WebSocket 接続 =====
  const proto = (location.protocol === 'https:') ? 'wss' : 'ws';
  const ws = new WebSocket(`${proto}://${location.host}`);

  let nextAt = 0;

  ws.onopen = () => {
    statusEl.textContent = '接続済み';
  };

  ws.onerror = (e) => {
    console.error('WS error', e);
    statusEl.textContent = '接続エラー';
  };

  ws.onclose = () => {
    statusEl.textContent = '切断（リロードで再接続）';
  };

  // サーバーからのメッセージ
  ws.onmessage = (ev) => {
    const data = JSON.parse(ev.data);

    if (data.type === 'init') {
      // 既存ピクセル一括反映
      drawGrid();
      const pixels = data.pixels || {};
      for (const key in pixels) {
        const [x, y] = key.split(',').map(Number);
        fillCell(x, y, pixels[key]);
      }
    } else if (data.type === 'draw') {
      fillCell(data.x, data.y, data.color);
    }
  };

  // クールダウン UI
  function updateCooldownUI() {
    const remain = Math.max(0, nextAt - Date.now());
    cdEl.textContent = (remain <= 0) ? 'OK' : (Math.ceil(remain / 1000) + 's');
  }
  setInterval(updateCooldownUI, 200);

  // クリック（＆タッチ）で設置 → サーバーに送信
  function handlePointer(clientX, clientY) {
    const rect = cv.getBoundingClientRect();
    const cx = Math.floor((clientX - rect.left) / CELL);
    const cy = Math.floor((clientY - rect.top) / CELL);
    if (cx < 0 || cy < 0 || cx >= W || cy >= H) return;

    const now = Date.now();
    if (now < nextAt) return; // クールダウン中

    const col = colorEl.value;
    // 先にローカル表示（体感を良くする）
    fillCell(cx, cy, col);

    // サーバーへ送信（全員へブロードキャストされる）
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(JSON.stringify({ type: 'draw', x: cx, y: cy, color: col }));
    }

    nextAt = now + COOLDOWN_MS;
    updateCooldownUI();
  }

  cv.addEventListener('click', (e) => handlePointer(e.clientX, e.clientY));
  cv.addEventListener('touchstart', (e) => {
    const t = e.touches[0];
    handlePointer(t.clientX, t.clientY);
    e.preventDefault();
  }, { passive: false });
})();
</script>
